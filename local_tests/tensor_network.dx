-- tensor_network.dx

-- 1. Define bond and physical dimensions as distinct index types
PhysDim = Fin 2     -- physical dimension (e.g., spin-1/2: up/down)
Bond1   = Fin 3     -- bond dimension between site 1 and site 2
Bond2   = Fin 3     -- bond dimension between site 2 and site 3

-- 2. Single tensor contraction: C_{ij} = sum_k A_{ik} B_{kj}
def mat_mul(A: m => k => Float, B: k => n => Float) -> m => n => Float
    given (m|Ix, k|Ix, n|Ix) =
  for i. for j. sum for c. A[i, c] * B[c, j]

-- Quick test: 2x3 times 3x2
A_test : (Fin 2) => (Fin 3) => Float = for i. for j.
  n_to_f ((ordinal i) * 3 + (ordinal j))

B_test : (Fin 3) => (Fin 2) => Float = for i. for j.
  n_to_f ((ordinal i) * 2 + (ordinal j))

C_test = mat_mul A_test B_test
-- Should be [[10, 13], [28, 40]]

-- =============================================================
-- 3. Tensor trace: Tr(A) = sum_i A_{ii}
-- =============================================================
def tensor_trace(A: n => n => Float) -> Float given (n|Ix) =
  sum for i. A[i, i]

-- =============================================================
-- 4. Build a 3-site Matrix Product State (MPS)
-- =============================================================
-- An MPS represents a many-body wavefunction as a chain of tensors:
--
--   psi_{s1, s2, s3} = sum_{a,b} A[s1, a] * B[a, s2, b] * C[b, s3]

-- Site 1: left boundary tensor (no left bond)
-- Shape: PhysDim => Bond1 => Float
T1 : PhysDim => Bond1 => Float = for s. for a.
  1.0 / (n_to_f ((ordinal s) + (ordinal a) + 1))

-- Site 2: bulk tensor (left bond, physical, right bond)
-- Shape: Bond1 => PhysDim => Bond2 => Float
T2 : Bond1 => PhysDim => Bond2 => Float = for a. for s. for b.
  select (ordinal a == ordinal b) 1.0 0.0

-- Site 3: right boundary tensor (no right bond)
-- Shape: Bond2 => PhysDim => Float
T3 : Bond2 => PhysDim => Float = for b. for s.
  1.0 / (n_to_f ((ordinal s) + (ordinal b) + 1))

-- =============================================================
-- 5. Contract the MPS to get the full wavefunction
-- =============================================================
-- psi[s1, s2, s3] = sum_a sum_b T1[s1, a] * T2[a, s2, b] * T3[b, s3]
--
-- The free indices (s1, s2, s3) produce the output shape.
-- The summed indices (a, b) are contracted away.
-- This is exactly Einstein notation, just with explicit sums.

psi : PhysDim => PhysDim => PhysDim => Float =
  for s1. for s2. for s3.
    sum for a:(Bond1).
      sum for b:(Bond2).
        T1[s1, a] * T2[a, s2, b] * T3[b, s3]

-- =============================================================
-- 6. Compute the norm: <psi|psi> = sum_{s1,s2,s3} |psi_{s1,s2,s3}|^2
-- =============================================================

norm_sq = sum for s1. sum for s2. sum for s3.
  psi[s1, s2, s3] * psi[s1, s2, s3]

psi_norm = sqrt norm_sq

-- =============================================================
-- 7. Transfer matrix: the core object in MPS algorithms
-- =============================================================
-- T_{(a,a'),(b,b')} = sum_s T2[a,s,b] * T2[a',s,b']
-- This contracts the physical index, leaving a matrix on
-- the doubled bond space. Used in computing expectations, etc.

transfer : Bond1 => Bond1 => Bond2 => Bond2 => Float =
  for a. for a'. for b. for b'.
    sum for s:(PhysDim).
      T2[a, s, b] * T2[a', s, b']

-- =============================================================
-- 8. Expectation value of a local operator on site 2
-- =============================================================

-- Pauli Z operator: diag(1, -1) in the computational basis
pauli_z : PhysDim => PhysDim => Float = for i. for j.
  select (ordinal i == ordinal j)
    (select (ordinal i == 0) 1.0 (-1.0))
    0.0

expectation_z = sum for s1. sum for s2. sum for s2'. sum for s3.
  sum for a:(Bond1). sum for b:(Bond2).
    sum for a':(Bond1). sum for b':(Bond2).
      T1[s1, a] * T2[a, s2, b] * T3[b, s3] *
      pauli_z[s2, s2'] *
      T1[s1, a'] * T2[a', s2', b'] * T3[b', s3]
